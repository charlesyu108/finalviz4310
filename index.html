<!DOCTYPE html>
<html>

<head>
  <script src="https://d3js.org/d3.v4.min.js"></script>
  <link href="styles.css" rel="stylesheet"></link>
  <!-- mapbox -->
  <script src='https://api.mapbox.com/mapbox-gl-js/v0.44.2/mapbox-gl.js'></script>
  <link href='https://api.mapbox.com/mapbox-gl-js/v0.44.2/mapbox-gl.css' rel='stylesheet' />
  <meta name='viewport' content='initial-scale=1,maximum-scale=1,user-scalable=no' />
  <script src='https://api.tiles.mapbox.com/mapbox-gl-js/v0.44.1/mapbox-gl.js'></script>
  <link href='https://api.tiles.mapbox.com/mapbox-gl-js/v0.44.1/mapbox-gl.css' rel='stylesheet' />
  <script src="https://d3js.org/d3-collection.v1.min.js"></script>
  <script src="https://d3js.org/d3-dispatch.v1.min.js"></script>
  <script src="https://d3js.org/d3-quadtree.v1.min.js"></script>
  <script src="https://d3js.org/d3-timer.v1.min.js"></script>
  <script src="https://d3js.org/d3-force.v1.min.js"></script>
</head>

<style>

  canvas {
    border:1px solid #ccc;
  }

</style>

<body>
  <h1>INFO 4310 Final Project</h1>
  <!-- <svg id="bubble-svg" width=800 height=600></svg> -->

</body>



<!-- <script>
  //Loading in Data
  d3.queue()
    .defer(d3.csv, "profiles.csv")
    .defer(d3.json, "okcupid.json")
    .await(makeViz);

  function makeViz(err, data, jsondata) {
    console.log("Data Loaded!", data.length);

    var sampleData = {
      "children": [{
          "text": "hello",
          "count": 20
        },
        {
          "text": "artsy",
          "count": 200
        },
        {
          "text": "adventurous",
          "count": 145
        },
        {
          "text": "love",
          "count": 305
        },
        {
          "text": "harry potter",
          "count": 30
        },
        {
          "text": "game of thrones",
          "count": 13
        },
        {
          "text": "san francisco",
          "count": 155
        },
        {
          "text": "fun",
          "count": 300
        },
        {
          "text": "amp",
          "count": 70
        },

      ]
    }
    var essayq = "essay6";

    var gender = "f";
    // var essayq = "essay0";
    var jData = jsondata.filter( d => (d.gender == gender && d.essay == essayq))[0];
    // jData.top_word = jData.top_word.slice(100, 200);
    console.log(jData);
    sampleData1 = {"children": jData.top_word.map(function (d){ return  {"text": d[0], "count": d[1], "gender": gender} }) };
    femaletext = sampleData1.children.map(d => d.text);

    var gender = "m";
    // var essayq = "essay0";
    var jData = jsondata.filter( d => (d.gender == gender && d.essay == essayq))[0];
    // jData.top_word = jData.top_word.slice(100, 200);
    console.log(jData);
    sampleData2 = {"children": jData.top_word.map(function (d){ return  {"text": d[0], "count": d[1], "gender": gender} }) };
    maletext = sampleData2.children.map(d => d.text);

    sampleData =  {"children": sampleData1.children.concat(sampleData2.children)};

    console.log(sampleData);
    console.log("shared", maletext.filter(d => femaletext.indexOf(d) > -1));
    console.log("male-only", maletext.filter(d => femaletext.indexOf(d) == -1));
    console.log("female-only", femaletext.filter(d => maletext.indexOf(d) == -1));




    //NOTE!: The "children" field is very important to include!

    var bubble_svg = d3.select("#bubble-svg"),
      width = +bubble_svg.attr("width"),
      height = +bubble_svg.attr("height");

    var color = d3.scaleOrdinal(d3.schemeCategory20);

    var bubble = d3.pack(sampleData)
      .size([width/2, height])
      .padding(1.5);

    var bubble_tooltip = d3.select("body").append("div")
      .style("position", "absolute")
      .html("test");

    var nodes = d3.hierarchy(sampleData)
      .sum(d => d.count);

    var node = bubble_svg.selectAll(".node")
      .data(bubble(nodes).descendants())
      .enter()
      .filter(d => !d.children)
      .append("g")
      .attr("class", "node")
      .attr("transform", d => "translate(" + d.x + "," + d.y + ")");

    node.append("title")
      .text(d => d.data.text);

    node.append("circle")
      .attr("r", d => d.r)
      .style("fill", (d, i) => (d.data.gender =="f" ? "red": "blue"));

    node.append("text")
      .attr("dy", ".2em")
      .attr("font-family", "sans-serif")
      .attr("text-anchor", "middle")
      .attr("font-size", (d => d.r / 5))
      .attr("fill", "white")
      .text(d => d.data.text)

    // Overlayed, transparent circle
    node.append("circle")
      .attr("class", "overlay")
      .attr("r", d => d.r)
      .style("opacity", 0)
      .on("mouseover", showToolTip)
      .on("mousemove", moveToolTip)
      .on("mouseout", hideToolTip);

    function moveToolTip(){
      bubble_tooltip
      .style("top", 12 + d3.event.pageY +"px")
      .style("left", 12 + d3.event.pageX+"px");
    }

    function showToolTip(){
      bubble_tooltip
      .style("display", "inline")
    }

    function hideToolTip(){
      bubble_tooltip
      .style("display", "none");
    }
  }

  //Bubble viz credit: https://bl.ocks.org/alokkshukla/3d6be4be0ef9f6977ec6718b2916d168
</script> -->

<script>

var width = 660,
    height = 500,
    padding = 1.5, // separation between same-color nodes
    clusterPadding = 6, // separation between different-color nodes
    maxRadius = 12;

var n = 200, // total number of nodes
    m = 2; // number of distinct clusters

var color = d3.scaleSequential(d3.interpolateRainbow)
    .domain(d3.range(m));

var clusters = new Array(m);

d3.json("okcupid.json", function(error, data) {
  if (error) throw error;

  var essayq = 0;

  nodes = [];

  data.forEach(function(point) {
    if(point.essay == "essay0") {
      var i = getCluster(point);
      point.top_word.forEach(function(p) {
        var r = getRadius(p[1]);
        var d = {
              cluster: i,
              radius: r,
              x: getX(i) + Math.random(),
              y: height / 2 + Math.random(),
              text: p[0]
            };
        if (!clusters[i] || (r > clusters[i].radius)) clusters[i] = d;
        nodes.push(d);
      })
    }
  });

  function getCluster(d) {
    if(d.gender == "f") {
      return 0;
    }
    else {
      return 1;
    }
  }

  function getRadius(d) {
    return d/500;
  }

  function getX(i) {
    if(i==0) {
      return (-width/2)
    }
    else if(i==1) {
      return (-width/4)
    }
    else {
      return (width/8)
    }
  }

  var force = d3.forceSimulation()
    // keep entire simulation balanced around screen center
    .force('center', d3.forceCenter(width/2, height/2))

    // cluster by section
    .force('cluster', cluster()
      .strength(0.3))

    // apply collision with padding
    .force('collide', d3.forceCollide(d => d.radius + padding)
      .strength(0.8))

    .on('tick', layoutTick)
    .nodes(nodes);
    
  var svg = d3.select("body").append("svg")
      .attr("width", width)
      .attr("height", height);

  var node = svg.selectAll("circle")
      .data(nodes)
    .enter().append("circle")
      .style("fill", function(d) { return color(d.cluster/3); })
      .on("click", function(d) { console.log(d)})
      .on("mouseover", function(d) {
          d3.select(this).style("cursor", "pointer"); 
        });

  var label = svg.selectAll(".myText")
            .data(nodes)
            .enter()
            .append("text")
              .text(function(d) {return d.text})
              .style("text-anchor", "middle")
              .style("fill", "#555")
              .style("font-family", "Arial")
              .style("font-size", 12);
    
  function layoutTick(e) {
    node
        .attr("cx", function(d) { return d.x; })
        .attr("cy", function(d) { return d.y; })
        .attr("r", function(d) { return d.radius; });
    label
        .attr("x", function(d) { return d.x} )
        .attr("y", function(d) { return d.y} );
  }

  // Move d to be adjacent to the cluster node.
  // from: https://bl.ocks.org/mbostock/7881887
  function cluster () {

    var nodes,
      strength = 0.1;

    function force (alpha) {

      // scale + curve alpha value
      alpha *= strength * alpha;

      nodes.forEach(function(d) {
        var cluster = clusters[d.cluster];
        if (cluster === d) return;
        
        let x = d.x - cluster.x,
          y = d.y - cluster.y,
          l = Math.sqrt(x * x + y * y),
          r = d.radius + cluster.radius;

        if (l != r) {
          l = (l - r) / l * alpha;
          d.x -= x *= l;
          d.y -= y *= l;
          cluster.x += x;
          cluster.y += y;
        }
      });

    }

    force.initialize = function (_) {
      nodes = _;
    }

    force.strength = _ => {
      strength = _ == null ? strength : _;
      return force;
    };

    return force;

}

});

</script>

</html>
