<!DOCTYPE html>
<html>

<head>
  <script src="https://d3plus.org/js/d3.js"></script>
  <script src="https://d3plus.org/js/d3plus.js"></script>
  <script src="https://d3js.org/d3.v4.min.js"></script>
  <link href="styles.css" rel="stylesheet"></link>
  <script src="https://d3js.org/d3-collection.v1.min.js"></script>
  <script src="https://d3js.org/d3-dispatch.v1.min.js"></script>
  <script src="https://d3js.org/d3-quadtree.v1.min.js"></script>
  <script src="https://d3js.org/d3-timer.v1.min.js"></script>
  <script src="https://d3js.org/d3-force.v1.min.js"></script>

</head>

<style>

  canvas {
    border:1px solid #ccc;
  }

</style>

<body>
  <h1>INFO 4310 Final Project</h1>
  <button id= "unsort">Unsort</button>
  <button id="gender">Show Gender</button>
  <button id="age">Show Age</button>
</body>


<script src="demographics.js"></script>

<script>

var width = 1200,
    height =550,
    padding = 1.5, // separation between same-color nodes
    clusterPadding = 6, // separation between different-color nodes
    maxRadius = 50;

var n = 200, // total number of nodes
    m = 2; // number of distinct clusters

var clusters = new Array(m);

d3.json("potato5.json", function(error, data) {
  if (error) throw error;

  var essayq = "essay4";

  nodes = [];

  var gender = "female";
  var jData = data.filter( d => (d.essay == essayq))[0];
  top_female = jData.female.slice(50, 150);
  sampleData1 = {"children": top_female.map(function (d){ return  {"text": d.word, "count": d.count, "gender": "f"} }) };
  femaletext = sampleData1.children.map(d => d.text);

  var gender = "male";
  var jData = data.filter( d => (d.essay == essayq))[0];
  top_male = jData.male.slice(50, 150);
  sampleData2 = {"children": top_male.map(function (d){ return  {"text": d.word, "count": d.count, "gender": "m"} }) };
  maletext = sampleData2.children.map(d => d.text);

  sampleData =  {"children": sampleData1.children.concat(sampleData2.children)};

  var gender = "both";
  var jData = data.filter( d => (d.essay == essayq))[0];
  top_both = jData.both.slice(100, 200);
  sampleData3 = {"children": top_both.map(function (d){ return  {"text": d.word, "count": d.count, "gender": "s"} }) };
  var sharedText = sampleData3.children.map(d => d.text);

  var maleData = sampleData2.children.filter(d => sharedText.indexOf(d.text) == -1);
  var femaleData = sampleData1.children.filter(d => sharedText.indexOf(d.text) == -1);
  var sharedData = sampleData3.children;

  sharedText = sharedText.slice(0,30);
  console.log("shared: "+JSON.stringify(sharedData));
  console.log("male: "+JSON.stringify(maleData));
  console.log("female: "+JSON.stringify(femaleData));

  sampleData.children.forEach(function(point) {
      var i = getCluster(point);
      var col = getColor(point);
      var r = getRadius(point.count.toFixed(0));
      var d = {
            cluster: i,
            radius: r,
            x: getX(i),
            y: (height) * Math.random(),
            color: col,
            text: point.text,
            count: point.count
          };
      if (!clusters[i] || (r > clusters[i].radius)) clusters[i] = d;
      nodes.push(d);


  });

  function getColor(point) {

    if(point.gender == "f" && sharedText.indexOf(point.text) == -1) {
      return "red"
    }
    else if(point.gender == "m" && sharedText.indexOf(point.text) == -1) {
      return "blue"
    }
    else {
      if(sharedText.indexOf(point.text) > -1) {
        return "#9932CC"
      }
    }
  }

  function getCluster(d) {
    if(d.gender == "f" && sharedText.indexOf(d.text) == -1) {
      return 0;
    }
    else if(d.gender == "m" && sharedText.indexOf(d.text) == -1) {
      return 2;
    }
    else {
      return 1;
    }
  }

  function getRadius(d) {
    return d/7;
  }

  function getX(i) {
    if(i==0) {
      return getRandom(0, width/4)
    }
    else if(i==1) {
      return getRandom(width/4, width/2)
    }
    else {
      return getRandom(width/2, width)
    }
  }

  function getRandom(min, max) {
    return Math.random() * (max - min) + min;
  }

  var force = d3.forceSimulation()

    // cluster by section
    .force('cluster', cluster()
      .strength(0.5))

    // apply collision with padding
    .force('collide', d3.forceCollide(d => d.radius + padding)
      .strength(0.7))

    .on('tick', layoutTick)
    .nodes(nodes);

  var svg = d3.select("body").append("svg")
      .attr("width", width)
      .attr("height", height);

  var node = svg.selectAll("circle")
      .data(nodes)
    .enter().append("circle")
      .style("fill", function(d) {return d.color})
      .on("click", function(d) { console.log(d)})
      .on("mouseover", function(d) {
          d3.select(this).style("cursor", "pointer");
        });

  var label = svg.selectAll(".myText")
            .data(nodes)
            .enter()
            .append("text")
              .text(function(d) {return d.text})
              .attr("class", "circleResize")
              .style("text-anchor", "middle")
              .style("fill", "#111")
              .style("font-family", "Arial")
              .style("font-size", 12)
             /* .style("font-size",function(d) { return Math.min(2 * d.r, (2 * d.r - 8) / this.getComputedTextLength() * 12) + "px"; })*/
              .on("mouseover", function(d) {
                d3.select(this).style("cursor", "pointer");
              });

  function layoutTick(e) {
    node
        .attr("cx", function(d) { return d.x = Math.max(d.radius, Math.min(width - d.radius, d.x)); })
        .attr("cy", function(d) { return d.y = Math.max(d.radius, Math.min(height - d.radius, d.y)); })
        .attr("r", function(d) { return d.radius; });
    label
        .attr("x", function(d) { return d.x} )
        .attr("y", function(d) { return d.y} );
  }

  function isolate(force, filter) {
    var initialize = force.initialize;
    force.initialize = function() { initialize.call(force, nodes.filter(filter)); };
    return force;
  }

  // Move d to be adjacent to the cluster node.
  // from: https://bl.ocks.org/mbostock/7881887
  function cluster () {

    var nodes,
      strength = 0.1;

    function force (alpha) {

      // scale + curve alpha value
      alpha *= strength * alpha;

      nodes.forEach(function(d) {
        var cluster = clusters[d.cluster];
        if (cluster === d) return;

        let x = d.x - cluster.x,
          y = d.y - cluster.y,
          l = Math.sqrt(x * x + y * y),
          r = d.radius + cluster.radius;

        if (l != r) {
          l = (l - r) / l * alpha;
          d.x -= x *= l;
          d.y -= y *= l;
          cluster.x += x;
          cluster.y += y;
        }
      });

    }

    force.initialize = function (_) {
      nodes = _;
    }

    force.strength = _ => {
      strength = _ == null ? strength : _;
      return force;
    };

    return force;

  }

});

</script>

</html>
